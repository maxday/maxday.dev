<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hey hey hey üçï!
This is the second part of this series, make sure you&rsquo;ve already read the first part :)
In the first part, we saw how to create a basic Rust API with a GET /pizza endpoint to retrieve the list of pizza.
In this part, let&rsquo;s see how to containerize our app!
Let&rsquo;s create our container
Since AWS App Runner is a fully managed container application service, we definitely need a container!"><title>Rust on AWS App Runner - Part 2
</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.35c42d788ab64156a7083a0054ba19dd8f79eac986fe869b731825c45b8e4a29a63628a438fd2ef54b4d0fa28b4d2d93309a885ccacdb28a54b425aa2ca3224a.css integrity="sha512-NcQteIq2QVanCDoAVLoZ3Y956smG/oabcxglxFuOSimmNiikOP0u9UtND6KLTS2TMJqIXMrNsopUtCWqLKMiSg=="><script defer data-domain=maxday.dev src=https://plausible.io/js/script.js></script><meta name=description content="Software Engineer, Serverless and Rust addict"><meta property="og:url" content="https://maxday.dev"><meta property="og:type" content="website"><meta property="og:title" content="Maxime David | maxday"><meta property="og:description" content="Software Engineer, Serverless and Rust addict"><meta property="og:image" content="https://maxday.dev/og.png"><meta name=twitter:card content="summary_large_image"><meta property="twitter:domain" content="maxday.dev"><meta property="twitter:url" content="https://maxday.dev"><meta name=twitter:title content="Maxime David | maxday"><meta name=twitter:description content="Software Engineer, Serverless and Rust addict"><meta name=twitter:image content="https://maxday.dev/og.png"><meta name=google-site-verification content="RU5jdXdJjFqFrujLcpVYIcMftJNOvEx8GpGjbZs_KP8"><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üî•</text></svg>"></head><body a=light><main class=page-content aria-label=Content><div class=w><a href=/>back</a><article><p class=post-meta><time datetime="2023-09-04 00:00:00 +0800 +0800">2023-09</time></p><h1>Rust on AWS App Runner - Part 2</h1><p>Hey hey hey üçï!</p><p>This is the second part of this series, make sure you&rsquo;ve already read <a href=https://dev.to/aws-builders/rust-on-aws-app-runner-part1-4hpp>the first part</a> :)</p><p>In the first part, we saw how to create a basic Rust API with a <code>GET /pizza</code> endpoint to retrieve the list of pizza.</p><p>In this part, let&rsquo;s see how to containerize our app!</p><h2 id=lets-create-our-container>Let&rsquo;s create our container</h2><p>Since AWS App Runner is a fully managed container application service, we definitely need a container!</p><p>In this section, we will see how to build that container thanks to <code>Docker</code> using a <code>Dockerfile</code>.</p><p>A <code>Dockerfile</code> is a text file that contains all the commands needed to build our container, it&rsquo;s often compared to a recipe.</p><h2 id=rust-as-the-base-image>Rust as the base image</h2><p>Let&rsquo;s start with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> rust:slim-bullseye</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./ /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> cargo build --release<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The first line describes the base image that we want to use, here the official <code>rust</code> one.</p><p>This is really convenient since we don&rsquo;t have to install <code>rust</code> or <code>cargo</code>: both are already installed in this base image.</p><p>Then we define the current working directory, here <code>/app</code></p><p>Then we copy our sources (<code>src</code> + <code>Cargo.toml</code> + <code>Cargo.lock</code>) into the container.</p><p>Finally we build our API directly inside the container, in release mode, to be sure to have a production-ready binary.</p><p>Great, we now have our binary ready in our image!</p><p>But wait, we also have <code>rust</code>, <code>cargo</code> and a bunch of useless tools at runtime.</p><p>It was convenient to use the official <code>rust</code> image <strong>to build</strong>, but we don&rsquo;t need it anymore for the <strong>runtime</strong>. Fortunately, Docker supports <strong>multi stage builds</strong>.</p><h2 id=multi-stage-builds>Multi-stage builds</h2><p>We can specify a base image to build and another one to run! That&rsquo;s exactly what we want!</p><p>The idea here is to have the smallest possible image so the cold start would be extremely fast. That&rsquo;s why we are going to use a <code>distroless</code> base image.</p><p>Those images are built by Google and contain almost nothing: no <code>bash</code>, no <code>ssh</code>, no utility tools which makes the image extremely small.</p><p>Let&rsquo;s modify our Dockerfile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> rust:slim-bullseye AS BUILD</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./ /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> cargo build --release<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> gcr.io/distroless/cc-debian10</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>BUILD /app/target/release/app-runner-rust / <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;./app-runner-rust&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Here we name our first image <code>BUILD</code> so we can reference that later. Then from the distroless image, we copy our binary from the <code>BUILD</code> image! Super convenient! I love Docker :D</p><p>Our runtime image is just the <code>distroless base image</code> + <code>rust binary</code></p><p>Let&rsquo;s finally build it with <code>docker build . -t maxday/app-runner</code></p><p>Let&rsquo;s check for our image size: <code>docker images | grep maxday/app-runner</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker images | grep maxday/app-runner
</span></span><span style=display:flex><span>maxday/app-runner                                          latest          e278afc78403   <span style=color:#ae81ff>3</span> minutes ago    20.1MB
</span></span></code></pre></div><p><strong>20.1MB!!! ü§Ø Extremely small!</strong></p><p>Woot woot! We now have a ready to deploy container!</p><h2 id=local-test>Local test</h2><p>Before deploying, let&rsquo;s make sure everything looks fine by running it locally and calling our <code>GET /pizza</code> endpoint.</p><p>You can run your newly built docker image with:<br><code>docker run -d -p 8080:8080 maxday/app-runner</code></p><ul><li><code>-d</code> means <code>detached</code> so the container runs in the background</li><li><code>-p 8080:8080</code> means that you&rsquo;re bridging the host port 8080 to the container port 8080.</li></ul><p>You can check that your container is up and running with:<br><code>docker ps</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker ps
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE               COMMAND               CREATED          STATUS          PORTS                    NAMES
</span></span><span style=display:flex><span>e5d8978ee6ee   maxday/app-runner   <span style=color:#e6db74>&#34;./app-runner-rust&#34;</span>   <span style=color:#ae81ff>53</span> seconds ago   Up <span style=color:#ae81ff>53</span> seconds   0.0.0.0:8080-&gt;8080/tcp   pedantic_kare
</span></span></code></pre></div><p>Now you can curl the endpoint:<br><code>curl http://localhost:8080/pizza</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl localhost:8080/pizza
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span><span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Margherita&#34;</span>,<span style=color:#e6db74>&#34;toppings&#34;</span>:<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;tomato&#34;</span>,<span style=color:#e6db74>&#34;fior di latte&#34;</span><span style=color:#f92672>]</span>,<span style=color:#e6db74>&#34;price&#34;</span>:10<span style=color:#f92672>}</span>,<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Veggie&#34;</span>,<span style=color:#e6db74>&#34;toppings&#34;</span>:<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;green peppers&#34;</span>,<span style=color:#e6db74>&#34;onion&#34;</span>,<span style=color:#e6db74>&#34;mushrooms&#34;</span><span style=color:#f92672>]</span>,<span style=color:#e6db74>&#34;price&#34;</span>:12<span style=color:#f92672>}]</span>
</span></span></code></pre></div><p>Awesome! üéâ</p><p><strong>Our container is now ready to be used by AWS App Runner.</strong></p><p>See you next week for the final episode of this series to deploy it!</p><p><strong>Like this content? Consider following me for more!</strong></p><p>A question? Feel free to use the comment section ‚¨áÔ∏è</p><p>You can find me on <a href=https://www.linkedin.com/in/maxday/>LinkedIn</a>, <a href=https://www.youtube.com/@maxday_coding>YouTube</a> and <a href=https://x.com/_maxday>X</a>!</p></article></div></main></body></html>