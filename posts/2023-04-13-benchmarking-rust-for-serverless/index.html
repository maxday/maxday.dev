<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Let&rsquo;s start with two very important questions:
Why should I care to benchmark Rust since it&rsquo;s already super fast? That&rsquo;s the question we&rsquo;ll try to answer in this post!
Will there be a üçï demo? Of course, you know that I&rsquo;m a true üçïüçïüçï lover!
What&rsquo;s so special about Serverless? Benchmarking is not specific to serverless. But in serverless components, such as AWS Lambda functions, performance really matters for two main reasons:"><title>Benchmarking Rust for Serverless</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.851225d8fa38226bab6e7d88356ad22d4feda354106364f25b97a6ab5a046d56c4fcc55ec60683b17f7aace257421d25b81dfe4c6fcc695afe934b370b480fb8.css integrity="sha512-hRIl2Po4Imurbn2INWrSLU/to1QQY2TyW5emq1oEbVbE/MVexgaDsX96rOJXQh0luB3+TG/MaVr+k0s3C0gPuA=="><script defer data-domain=maxday.dev src=https://plausible.io/js/script.js></script><meta name=description content="Software Engineer, Serverless and Rust addict"><meta property="og:url" content="https://maxday.dev"><meta property="og:type" content="website"><meta property="og:title" content="Maxime David | maxday"><meta property="og:description" content="Software Engineer, Serverless and Rust addict"><meta property="og:image" content="https://maxday.dev/og.png"><meta name=twitter:card content="summary_large_image"><meta property="twitter:domain" content="maxday.dev"><meta property="twitter:url" content="https://maxday.dev"><meta name=twitter:title content="Maxime David | maxday"><meta name=twitter:description content="Software Engineer, Serverless and Rust addict"><meta name=twitter:image content="https://maxday.dev/og.png"><meta name=google-site-verification content="RU5jdXdJjFqFrujLcpVYIcMftJNOvEx8GpGjbZs_KP8"><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üî•</text></svg>"></head><body a=light><main class=page-content aria-label=Content><div class=w><a href=/>back</a><article><p class=post-meta><time datetime="2023-04-13 00:00:00 +0800 +0800">2023-04</time></p><h1>Benchmarking Rust for Serverless</h1><p>Let&rsquo;s start with two <strong>very</strong> important questions:</p><ol><li>Why should I care to <strong>benchmark</strong> Rust since it&rsquo;s already super fast?</li></ol><p>That&rsquo;s the question we&rsquo;ll try to answer in this post!</p><ol start=2><li>Will there be a üçï demo?</li></ol><p>Of course, you know that I&rsquo;m a true üçïüçïüçï lover!</p><p><img src=/blog-benchmark-rust.png alt="benchmark rust"></p><h3 id=whats-so-special-about-serverless>What&rsquo;s so special about Serverless?</h3><p>Benchmarking is not specific to serverless. But in serverless components, such as AWS Lambda functions, performance really matters for two main reasons:</p><ul><li><p><strong>Cold start duration</strong> (good news, Rust is really performant as you can see in <a href=https://maxday.github.io/lambda-perf>my daily updated benchmark</a>)</p></li><li><p><strong>Runtime duration</strong>, as AWS is billing <strong>per millisecond</strong>.</p></li></ul><p>Let&rsquo;s see how we can measure and improve this runtime duration using benchmarks!</p><h3 id=what-are-we-going-to-benchmark>What are we going to benchmark?</h3><p>Let&rsquo;s take a very simple example:<br><code>a function which returns the pizza of the day.</code> üçï (I told you)</p><p>We will compare two different implementations:</p><ul><li>one with HashMap - <code>std::collections::HashMap</code></li><li>one with Vec - <code>std::vec::Vec</code></li></ul><p>First, let&rsquo;s define our <code>PizzaStore</code> trait:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> PizzaStore {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_pizza_of_the_day</span>(<span style=color:#f92672>&amp;</span>self, day_index: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And our first implementation with HashMap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// let&#39;s make sure we don&#39;t initialize a new HashMap each time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PizzaHashMap</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    cache: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>, 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> PizzaHashMap<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        PizzaHashMap {
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>HashMap</span>::from([
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;margherita&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;deluxe&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;veggie&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;mushrooms&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;bacon&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#34;four cheese&#34;</span>),
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>6</span>, <span style=color:#e6db74>&#34;pepperoni&#34;</span>),
</span></span><span style=display:flex><span>                <span style=color:#75715e>// what&#39;s your favorite?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ]),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> PizzaStore <span style=color:#66d9ef>for</span> PizzaHashMap<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// let&#39;s get the pizza of the day from the cache (HashMap)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_pizza_of_the_day</span>(<span style=color:#f92672>&amp;</span>self, day_index: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.cache.get(<span style=color:#f92672>&amp;</span>day_index) {
</span></span><span style=display:flex><span>            Some(<span style=color:#f92672>&amp;</span>pizza) <span style=color:#f92672>=&gt;</span> pizza,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;could not find the pizza&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=writing-our-first-benchmark>Writing our first benchmark</h3><p>There are quite some crates to create benchmarks but we&rsquo;ll use <code>criterion</code> here.
Let&rsquo;s start by creating a <code>benches</code> folder containing a <code>benchmark.rs</code> file and add our first criterion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>criterion_hashmap</span>(c: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Criterion) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rng <span style=color:#f92672>=</span> rand::thread_rng();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we create the cache outside of the bench function so only one HashMap will be created
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> pizza_store_hashmap <span style=color:#f92672>=</span> PizzaHashMap::new();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we call get_pizza_of_the_day with a random day index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    c.bench_function(<span style=color:#e6db74>&#34;with hashmap&#34;</span>, <span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.iter(<span style=color:#f92672>||</span> pizza_store_hashmap.get_pizza_of_the_day(rng.gen_range(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>7</span>))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also need a bench group (as we will add more criterion later)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>criterion_group!(benches, criterion_hashmap);
</span></span><span style=display:flex><span>criterion_main!(benches);
</span></span></code></pre></div><p>That&rsquo;s it! Let&rsquo;s run it with <code>cargo bench</code></p><p>By default, it runs our function for about 5seconds (that&rsquo;s about 300M+ iterations)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>     Running benches<span style=color:#f92672>/</span>benchmark.rs (target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>deps<span style=color:#f92672>/</span>benchmark<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>f28819806c8c7c9)
</span></span><span style=display:flex><span>with hashmap            time:   [<span style=color:#ae81ff>13.069</span> ns <span style=color:#ae81ff>13.090</span> ns <span style=color:#ae81ff>13.114</span> ns]
</span></span></code></pre></div><p>Left and right values are lower and upper bounds.</p><p>The number in the middle is the best estimation on how long each iteration is likely to take.</p><p><em>Note that those 3 numbers are extremely alike. This won&rsquo;t be the case if you&rsquo;re depending on networking for instance.</em></p><h3 id=second-implementation-with-vec>Second implementation: with Vec</h3><p>Let&rsquo;s create a different implementation using Vec instead of using HashMap using the following code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PizzaVec</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    cache: Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> PizzaVec<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        PizzaVec {
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#e6db74>&#34;margherita&#34;</span>,<span style=color:#e6db74>&#34;deluxe&#34;</span>,<span style=color:#e6db74>&#34;veggie&#34;</span>,<span style=color:#e6db74>&#34;mushrooms&#34;</span>,<span style=color:#e6db74>&#34;bacon&#34;</span>,<span style=color:#e6db74>&#34;four cheese&#34;</span>,<span style=color:#e6db74>&#34;pepperoni&#34;</span>],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> PizzaStore <span style=color:#66d9ef>for</span> PizzaVec<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_pizza_of_the_day</span>(<span style=color:#f92672>&amp;</span>self, day_index: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.cache.get(day_index <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>            Some(<span style=color:#f92672>&amp;</span>pizza) <span style=color:#f92672>=&gt;</span> pizza,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;could not find the pizza&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s create a new criterion so we can compare (that&rsquo;s the goal of benchmarks!)<br>Back in <code>benchmark.rs</code> we can add</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>criterion_vec</span>(c: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Criterion) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rng <span style=color:#f92672>=</span> rand::thread_rng();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pizza_store_vec <span style=color:#f92672>=</span> PizzaVec::new();
</span></span><span style=display:flex><span>    c.bench_function(<span style=color:#e6db74>&#34;with vector&#34;</span>, <span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.iter(<span style=color:#f92672>||</span> pizza_store_vec.get_pizza_of_the_day(rng.gen_range(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>7</span>))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and update our group to include this new criterion:</p><p><code>criterion_group!(benches, criterion_hashmap, criterion_vec);</code></p><p>so we can re-run our benchmarks with : <code>cargo bench</code></p><p>and check the result!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>with hashmap            time:   [<span style=color:#ae81ff>13.096</span> ns <span style=color:#ae81ff>13.117</span> ns <span style=color:#ae81ff>13.141</span> ns]
</span></span><span style=display:flex><span>with vector             time:   [<span style=color:#ae81ff>7.5832</span> ns <span style=color:#ae81ff>7.5958</span> ns <span style=color:#ae81ff>7.6097</span> ns]
</span></span></code></pre></div><p>By replacing our HashMap with a Vec, our program is now running almost <strong>twice as fast</strong>!</p><p>This is a great reminder on how the data structure choice is really important depending on the use case üòá</p><h3 id=ok-great-but-how-does-it-translate-to-serverless>Ok great, but how does it translate to Serverless?</h3><p>Two AWS Lambda Functions have been deployed embedding each one of the implementations.</p><p>Each lambda function calls <strong>10_000_000 times</strong> <code>get_pizza_of_the_day</code></p><p>In <code>us-east-1</code> with <code>128MB</code>, here are the results:</p><table><thead><tr><th>Implementation</th><th>Runtime duration</th></tr></thead><tbody><tr><td>HashMap</td><td>267.92 ms</td></tr><tr><td>Vec</td><td>87.98 ms ü§Øü§Ø</td></tr></tbody></table><p>That&rsquo;s it!</p><p>Of course this was a simple example but I hope I&rsquo;ve convinced you to use benchmarks to optimize your code!</p><p><strong>Bonus question:</strong> where does this overhead come from?</p><p>Stay tuned for the next blog post about <strong>Rust profiling</strong>!</p><p>‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è Did you like this content? ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</p><ul><li>Follow me on <a href=https://linkedin.com/in/maxday>LinkedIn</a> & <a href=https://twitter.com/_maxday>Twitter</a></li><li>Check my <a href=https://youtube.com/@maxday_coding>Rust Youtube channel</a></li><li>Share with your friends &lt;3</li></ul></article></div></main></body></html>